---
title: "Configuring Hedera gRPC access"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Configuring Hedera gRPC access}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)
```

Hadeda delegates all gRPC traffic to user-supplied handler functions that live in `config$grpc`. This vignette walks through a fully worked example that compiles Hedera protobuf definitions, establishes a channel, configures Ed25519 signing, and wires everything into Hadeda so that functions such as `crypto_account_info()` can execute over gRPC.

Because this vignette interacts with live Hedera endpoints you must provide a funded testnet account via the `HADEDA_OPERATOR_ID` and `HADEDA_OPERATOR_KEY` environment variables. When these variables are missing the helper functions introduced below will raise informative errors so you can follow the "Environment setup instructions to allow gRPC testing" guide shipped with the
package.

## Prerequisites

```{r}
install_if_missing <- function(package, install_call) {
  if (!requireNamespace(package, quietly = TRUE)) {
    message(sprintf("Installing %s...", package))
    eval(install_call)
  }
}

install_if_missing("pak", quote(install.packages("pak")))
install_if_missing("credentials", quote(install.packages("credentials")))
install_if_missing("remotes", quote(install.packages("remotes")))
install_if_missing("jsonlite", quote(install.packages("jsonlite")))
install_if_missing("RProtoBuf", quote(install.packages("RProtoBuf")))
install_if_missing("here", quote(install.packages("here")))

if (requireNamespace("credentials", quietly = TRUE)) {
  credentials::git_credential_ask()
}

if (!requireNamespace("hadeda", quietly = TRUE)) {
  remotes::install_github("NovaInstitute/Hadeda")
}

if (!requireNamespace("grpc", quietly = TRUE)) {
  remotes::install_github("christiaanpauw/grpc")
}

if (requireNamespace("pak", quietly = TRUE)) {
  pak::pak("openssl")
} else {
  install_if_missing("openssl", quote(install.packages("openssl")))
}

library(hadeda)
library(grpc)
library(jsonlite)
library(RProtoBuf)
library(here)
```

You also need the Protocol Buffers compiler (`protoc`) and, for convenience,
the `grpcurl` command line utility. Both tools are available via Homebrew,
Chocolatey, or package managers for most Linux distributions.

```{r proto_dependency_check, eval=TRUE}
has_protoc <- system("protoc --version", ignore.stdout = TRUE, ignore.stderr = TRUE) == 0
has_grpcurl <- system("grpcurl --version", ignore.stdout = TRUE, ignore.stderr = TRUE) == 0

if (has_protoc && has_grpcurl) {
  message("`protoc` and `grpcurl` are already available on this system.")
} else {
  if (!has_protoc) {
    message("`protoc` is not installed. Use the commands below to add it before proceeding.")
  }
  if (!has_grpcurl) {
    message("`grpcurl` is not installed. Use the commands below to add it before proceeding.")
  }
}
```

```sh
# macOS using Homebrew
brew install protobuf grpcurl

# Ubuntu
sudo apt-get install -y protobuf-compiler
curl -L https://github.com/fullstorydev/grpcurl/releases/latest/download/grpcurl_`uname -s | tr '[:upper:]' '[:lower:]'`_x86_64.tar.gz \
  | tar -xz -C /usr/local/bin grpcurl
```

## Download the Hedera protobuf definitions

Hedera publishes versioned protobuf bundles on GitHub. The
`hadeda_grpc_use_proto_bundle()` helper downloads a release archive, extracts it
into a local directory, and returns the path you can pass to the compiler and
`grpc` package.

```{r}
bundle_dest <- here::here("proto")
if (!dir.exists(bundle_dest)) {
  proto_root <- hadeda_grpc_use_proto_bundle(dest = bundle_dest, version = "0.47.0")
} else {
  proto_root <- normalizePath(bundle_dest)
  message(sprintf("Using existing proto bundle at %s", proto_root))
}
list.files(proto_root, recursive = FALSE)
```

The Hedera repository organises protobuf files under the `services/` directory,
which includes the service definitions alongside shared message types such as
`query.proto` and `transaction.proto`. For the example we only need the
CryptoService and basic response types.

```{r}
needed <- c(
  "services/crypto_service.proto",
  "services/network_service.proto"
)
needed
```

The service definitions import shared message types such as `query.proto`, so
keep the bundle intact when wiring everything together in R.

## Register services with the `grpc` package

Recent releases of the R `grpc` package consume `.proto` definitions directly
instead of relying on precompiled descriptor sets. Gather the directories that
contain Hedera's schemas and forward them to `hadeda_read_services2()` via the
`proto_path` argument so that `RProtoBuf` can resolve shared imports before
parsing the service declarations.

```{r}
proto_paths <- c(proto_root, file.path(proto_root, "services"))

crypto_stubs <- hadeda_read_services2(
  file.path(proto_root, "services", "crypto_service.proto"),
  proto_path = proto_paths
)
network_stubs <- hadeda_read_services2(
  file.path(proto_root, "services", "network_service.proto"),
  proto_path = proto_paths
)
```

If you see an error such as `google/protobuf/wrappers.proto:0:1: File not found`,
the Hedera bundle has been located correctly but the standard Google protobuf
definitions are still missing from the import path. Installing `protoc` via
Homebrew provides those headers under `file.path(system2("brew", c("--prefix",
"protobuf"), stdout = TRUE), "include")`. Instead of adding that path manually,
call `hadeda_find_protobuf_include()` to detect system installations and extend
`proto_paths` with the discovered directories before reloading the services:

```{r}
google_proto_paths <- hadeda_find_protobuf_include()
proto_paths <- unique(c(proto_paths, google_proto_paths))

crypto_stubs <- hadeda_read_services2(
  file.path(proto_root, "services", "crypto_service.proto"),
  proto_path = proto_paths
)
network_stubs <- hadeda_read_services2(
  file.path(proto_root, "services", "network_service.proto"),
  proto_path = proto_paths
)
```

On other platforms, set the `PROTOBUF_INCLUDE` environment variable to the
directory that contains `google/protobuf` before running the helper so that
the search can locate the headers automatically.

The `grpc::grpc_client()` helper turns those stubs into callables bound to a
channel. The `christiaanpauw/grpc` fork used by Hadeda manages the channel
internally whenever you pass a target string, so the factory simply echoes the
destination address. TLS options cannot be adjusted from R at the moment
because the fork only exposes insecure channels.

```{r}
channel_factory <- function(target = "testnet.hedera.com:50211") {
  target
}

crypto_service <- function(channel) {
  grpc::grpc_client(crypto_stubs, channel)
}

network_service <- function(channel) {
  grpc::grpc_client(network_stubs, channel)
}
```

The service definitions expose RPC methods as R functions. For example
`crypto_service(channel)$cryptoGetAccountInfo$call()` performs a unary request
when supplied with a `proto.Query` message. The next section shows how to build
those messages from tidy R data frames using the RProtoBuf descriptors.

## Build request payloads

RProtoBuf descriptors include message factories that convert between R lists and
protobuf binaries. A small helper wraps `RProtoBuf::new()` to create the `Query`
and `Transaction` payloads required by Hedera.

```{r}
proto_message <- function(type) {
  descriptor <- RProtoBuf::P(type)
  function(...) {
    do.call(RProtoBuf::new, c(list(descriptor), list(...)))
  }
}

query_header <- proto_message("proto.QueryHeader")
account_id_message <- proto_message("proto.AccountID")
timestamp_message <- proto_message("proto.Timestamp")
duration_message <- proto_message("proto.Duration")
transaction_id_message <- proto_message("proto.TransactionID")
transfer_list_message <- proto_message("proto.TransferList")
account_amount_message <- proto_message("proto.AccountAmount")
crypto_transfer_message <- proto_message("proto.CryptoTransferTransactionBody")
signature_map_message <- proto_message("proto.SignatureMap")
signature_pair_message <- proto_message("proto.SignaturePair")

to_account_id <- function(id) {
  parts <- as.integer(strsplit(id, "\\.")[[1]])
  account_id_message(
    shardNum = parts[1],
    realmNum = parts[2],
    accountNum = parts[3]
  )
}

now_timestamp <- function() {
  instant <- as.integer(as.numeric(Sys.time()))
  timestamp_message(seconds = instant, nanos = 0L)
}

crypto_get_account_info <- proto_message("proto.CryptoGetInfoQuery")
query_wrapper <- proto_message("proto.Query")
```

Queries include a header that identifies the payer account and optionally the
payment transaction. Hedera allows free queries up to a network-configured
threshold; for this vignette we start by asking the network to price the query
before submitting payment.

Before creating the signer, make sure `HADEDA_OPERATOR_KEY` references a PEM
encoded private key. If your operator secret is provided as a hexadecimal DER
string, Hadeda can convert and store it for you:

```{r eval=FALSE}
hadeda_write_operator_key(
  "302e020100300506032b657004220420e638e087c0dfe201b3519bd442033eba27b961a5fc969a7f4911b13ea2315769"
)
```

The helper writes the key to `hadeda_operator_key_path()` (for example
`~/.config/hadeda/operator_ed25519.pem`) and updates the environment variable so
that subsequent calls see the PEM file automatically.

```{r}
operator <- hadeda_grpc_env_credentials()
sign_transaction <- hadeda_grpc_ed25519_signer()
operator$public_key <- hadeda_grpc_signer_public_key(sign_transaction)
```

> **Security tip**
> `hadeda_grpc_env_credentials()` expects your operator key to arrive via the
> environment. Convert hex keys with `hadeda_write_operator_key()` and prefer
> storing the resulting PEM path in an OS-backed keyring (`keyring::key_set_with_value()` /
> `keyring::key_get()`) or exporting it with `withr::with_envvar()` instead of
> committing it to `.Renviron`. When running interactively, `keyring` paired with
> `askpass::askpass()` keeps secrets out of console history while still allowing
> on-demand prompts.

The CryptoGetInfo query uses a two-step process:

1. Submit a COST_ANSWER query with an empty payment to retrieve the fee.
2. Assemble a second query that includes the payment transaction signed by the
   operator key.

The helper below simplifies those steps and returns a tidy list compatible with
Hadeda's gRPC expectations.

```{r}
crypto_cost_query <- function(account_id, channel = NULL) {
  if (is.null(channel)) {
    channel <- channel_factory()
    destroy_channel <- get0(
      "grpc_channel_destroy",
      envir = asNamespace("grpc"),
      inherits = FALSE
    )
    if (is.null(destroy_channel)) {
      destroy_channel <- get0(
        "channel_destroy",
        envir = asNamespace("grpc"),
        inherits = FALSE
      )
    }
    if (!is.null(destroy_channel) && inherits(channel, "grpc_channel")) {
      on.exit(destroy_channel(channel), add = TRUE)
    }
  }

  client <- crypto_service(channel)
  cost_query <- query_wrapper(
    cryptogetaccountinfo = crypto_get_account_info(
      header = query_header(responseType = "COST_ANSWER"),
      accountID = to_account_id(account_id)
    )
  )

  response <- client$cryptoGetAccountInfo$call(cost_query)
  as.list(response)
}
```

The network returns the required fee under `responseHeader.cost`. Use this value
when building the signed payment transaction. The call to
`hadeda_grpc_ed25519_signer()` earlier in the vignette already prepared a
closure named `sign_transaction` that we reuse for the signed payment.

Constructing the payment transaction requires the transaction body bytes and a
signature map. The snippet below encodes the inner transaction using the
`TransactionBody` message and signs it.

```{r}
transaction_body <- proto_message("proto.TransactionBody")
transaction <- proto_message("proto.Transaction")

build_payment <- function(operator, account_id, cost, valid_duration = 120L) {
  pub_key <- hadeda_grpc_signer_public_key(sign_transaction)
  body <- transaction_body(
    transactionID = transaction_id_message(
      accountID = to_account_id(operator$operator_account_id),
      transactionValidStart = now_timestamp()
    ),
    nodeAccountID = to_account_id("0.0.3"),
    transactionFee = cost,
    transactionValidDuration = duration_message(seconds = as.integer(valid_duration)),
    cryptoTransfer = crypto_transfer_message(
      transfers = transfer_list_message(
        accountAmounts = list(
          account_amount_message(
            accountID = to_account_id(operator$operator_account_id),
            amount = -cost
          ),
          account_amount_message(
            accountID = to_account_id("0.0.3"),
            amount = cost
          )
        )
      )
    )
  )

  body_bytes <- RProtoBuf::serialize(body, NULL)
  sig_bytes <- sign_transaction(body_bytes)
  signature_map <- signature_map_message(
    sigPair = list(
      signature_pair_message(
        pubKeyPrefix = pub_key,
        ed25519 = sig_bytes
      )
    )
  )

  signed_transaction <- transaction(
    bodyBytes = body_bytes,
    sigMap = signature_map
  )

  RProtoBuf::serialize(signed_transaction, NULL)
}
```

With the payment prepared we can request account information over gRPC.

```{r}
query_account_info <- function(config, account_id) {
  channel <- config$grpc$channel()
  destroy_channel <- get0(
    "grpc_channel_destroy",
    envir = asNamespace("grpc"),
    inherits = FALSE
  )
  if (is.null(destroy_channel)) {
    destroy_channel <- get0(
      "channel_destroy",
      envir = asNamespace("grpc"),
      inherits = FALSE
    )
  }
  if (!is.null(destroy_channel) && inherits(channel, "grpc_channel")) {
    on.exit(destroy_channel(channel))
  }

  cost_response <- crypto_cost_query(account_id, channel)
  cost <- cost_response$cryptogetaccountinfo$responseHeader$cost
  payment <- build_payment(config$grpc$operator, account_id, cost)

  query_message <- query_wrapper(
    cryptogetaccountinfo = crypto_get_account_info(
      header = query_header(
        responseType = "ANSWER_ONLY",
        payment = transaction(signedTransactionBytes = payment)
      ),
      accountID = to_account_id(account_id)
    )
  )

  client <- crypto_service(channel)
  response <- client$cryptoGetAccountInfo$call(query_message)
  as.list(response)
}
```

## Register the handler with Hadeda

Combine the pieces into a `config$grpc` list that Hadeda understands. We keep
references to the operator credentials, the channel factory, and the signer.

```{r}
grpc_handler <- list(
  operator_account_id = operator$operator_account_id,
  operator = operator,
  channel = channel_factory,
  sign_transaction = sign_transaction,
  get_account_info = function(config, account_id) {
    query_account_info(config, account_id)
  }
)

grpc_config <- hadeda_config(network = "testnet", default_transport = "grpc")
grpc_config$grpc <- modifyList(grpc_config$grpc, grpc_handler)
```

Now calling `crypto_account_info()` uses the custom handler to perform a gRPC
query end-to-end.

```{r}
info <- crypto_account_info(grpc_config, operator$operator_account_id)
info
```

The returned tibble matches the schema from Hadeda's REST implementation but is
sourced directly from Hedera consensus nodes through gRPC.

## Troubleshooting

- Ensure `HADEDA_OPERATOR_ID` and `HADEDA_OPERATOR_KEY` are exported in the shell
  where you knit this vignette. The helpers stop early with actionable error
  messages when they are missing.
- gRPC requires HTTP/2 with TLS. When connecting to Hedera's testnet include the
  `grpc.ssl_target_name_override` option shown above so the certificate matches
  the service name.
- If `grpc::read_services()` reports unresolved imports, confirm that the
  `proto_paths` vector contains every directory referenced by your service
  definitions before reloading them with `hadeda_read_services2()`.
- When the network rejects a transaction because of invalid signatures, double
  check that the Ed25519 key is correct and that your system clock is in sync.

## Next steps

Use the same pattern to implement handlers for other services such as
`consensus_submit_message()` or token management RPCs. The loaded protobuf
descriptors and helper builders allow you to build and sign any Hedera
transaction using tidy R tooling while keeping cryptographic material under your
control.
